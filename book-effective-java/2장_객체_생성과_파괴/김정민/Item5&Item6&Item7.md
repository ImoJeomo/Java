# Item 5 : 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

- 클래스가 내부적으로 하나 이상의 자원에 의존하고 , 그 자원이 클래스 동작에 영향을 준다면 싱글턴과 정적 유틸리티 클래스는 사용하지 않는게 좋다.
- 인스턴스를 생성할 때 생성자에게 필요한 자원을 넘겨주자.
  - 팩터리 메서드 패턴

# Item 6 : 불필요한 객체 생성을 피하라

```java
String s = new String("bikini"); //1. no
String s = "bikini"; //2. yes
```

- 1번의 경우 실행될 때마다 새로운 String 인스턴스를 새로 만든다.
- 2번의 경우 새로운 인스턴스를 만드는 대신 하나의 String 인스턴스를 사용하다.

- 불변 클래스에서는 정적 팩터리 메서드를 사용해 불필요한 객체 생성을 피할 수 있다.

```java

public class RomanNumerals{
    private static final Pattern ROMAN = Pattern.compile(...);

    static boolean isRomanNumeral(String s){
        return ROMAN.matcher(s).matches();
    }

}
```

- Pattern 인스턴스는 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 된다. 인스턴스 생성 비용이 높다.
- 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용한다.

- 박싱된 기본 타입보다는 기본타입을 사용하고, 의도치 않은 오토 박싱이 숨어 들지 않게 한다.

- 기존 객체를 재사용하지 말아야하는 상황일 때(방어적 복사) 기존 객체를 재사용해 발생하는 피해가 더 크다.
- 기존 객체를 재사용했을 때는 버그와 보안 문제로 이어지지만 불필요한 객체를 생성할 때는 성능에만 영향을 주기 때문이다.

# Item 7 : 다 쓴 객체 참조를 해제하라

- 스택에서 꺼내진 객체들은 다 쓴 참조(obsolete reference)를 가지고있기 때문에 가비지 컬렉터가 회수하지 않는다.
- 해당 참조를 다 썼을 때 null 처리를 하자 (참조해제)
  - 모든 객체를 사용 후 null 처리하는게 아니라 예외적인 경우만 null처리를한다.
  - 자기 메모리를 직접 관리하는 클래스라면 메모리 누수에 주의하자.
- 캐시는 메모리 누수를 일으킨다.
  - 외부에서 키를 참조하는 동안만 엔트리가 살아 있는 캐시가 필요한 상황이라면 WeakHashMap을 사용해 캐시를 만들자.
  - 캐시 엔트리의 유효기간을 정확히 정의하기 어렵기 때문에 시간이 지날수록 엔트리의 가치를 떨어트리는 방식을 흔히 사용한다.
- 리스너(콜백) 은 메모리 누수를 일으킨다.
