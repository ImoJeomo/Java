# Item 6 - 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 좋을 때가 많다.

```java
String s1 = new String("bikini");
String s2 = new String("bikini");
```

위 코드는 실행될 때마다 String 인스턴스를 새로 만든다. heap 영역에 String 인스턴스가 계속 쌓이게 되는 것인데 이를 개선하기 위해서는

```java
String s1 = "bikini";
String s2 = "bikini";
```

이렇게 사용하면 새로운 인스턴스를 매번 만드는 대신 하나의 String 인스턴스를 재사용한다.

대부분의 경우에 문자열 리터럴을 사용하는 방식이 메모리 성능을 최적화할 수 있으니 아래 방식을 사용하도록 하자.

생성 비용이 아주 비싼 객체도 많이 있는데 이런 비싼 객체가 반복해서 필요하다면 캐싱해서 재사용하는 것이 좋다.

물론 자신이 만드는 객체가 비싼 객체인지를 매번 명확히 알기란 어려운 일이긴 하지만 아래 기준에 부합하다면 생성 비용이 비싼 객체라고 생각해도 좋을 것 같다.

- 크기가 아주 큰 Array
- Database Connection
- I/O 작업을 필요로 하는 Object
- 메모리, 네트워크 대역폭, 디스크 사용량 등 리소스를 많이 먹는 부분

그리고 책에서 예시로 설명하고 있는 코드가 있다.

```java
static boolean isRomanNumeralSlow(String s) {
    return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
            + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

위 코드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만 `String.matches` 메서드를 사용한다는 점이 문제라고 한다.

> 정규표현식 ?
정규 표현식(Regular Expression, Regex)은 문자열에서 특정한 패턴을 찾거나 조작하기 위해 사용하는 매우 강력한 도구이다.
> 

이 matches 메서드가 내부에서 만드는 정규표현식용 Pattern 인스턴스는 한번 쓰고 버려져서 곧바로 가비지 컬렉터 대상이 된다고 한다. Pattern은 입력받는 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 인스턴스 생성 비용이 높으니 성능이 중요한 코드에서 사용하기에는 적합하지 않다.

이를 개선하기 위해서는 정규표현식을 표현하는 불변인 Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 나중에 isRomanNumeral 메서드가 호출될 때마다 이 인스턴스를 재사용하게 하면 된다.

```java
// 미리 컴파일 해놓은 객체를 불러 사용하는 방식으로 개선했다 
private static final Pattern ROMAN = Pattern.compile(
    "^(?=.)M*(C[MD]|D?C{0,3})"
        + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

static boolean isRomanNumeralFast(String s) {
    return ROMAN.matcher(s).matches();
}
```

위 코드로 개선하기 전에는 문자열 매칭이 호출될 때마다 컴파일 비용이 발생했으나 개선 후에는 정규 표현식이 한 번만 컴파일되고, 이후에는 재사용하니 성능을 개선할 수 있게 되었다.

만약 개선된 isRomanNumeral 방식의 클래스가 초기화된 후 이 메서드를 한번도 호출하지 않는다면 ROMAN 필드는 쓸데없이 초기화된 꼴이다. 지연 초기화로 불필요한 초기화를 없앨 수는 있으나 코드를 복잡하게 만들고 성능은 크게 개선되지 않을 때가 많아서 권하지는 않는다고 한다.

객체가 불변임이 보장된다면 재사용해도 안전함이 명확하지만, 하지만 애매하거나, 내가 생각한것과 다를수도 있다.

예를 들어 어댑터를 생각했을 때, 어댑터는 인터페이스를 통해서 뒤에 있는 객체로 연결해주는 객체이기 때문에 여러개를 만들 필요가 없다.

Map 인터페이스의 keySet 메서드는 Map 객체 안의 키 전부를 담은 Set 뷰를 반환한다.

겉으로 보기에는 keySet 을 호출할 때마다 새로운 Set 인스턴스가 만들어지리라고 생각할 수 있지만, 사실은 같은 Set 인스턴스를 반환하기 때문에 반환된 객체 중 하나를 수정하면 모든 객체가 변경되게 된다.

이처럼 내가 생각한 것과는 다를 수도 있기 때문에 잘 확인하고 사용해야 할 것이다.

그리고 불필요한 객체를 만들어내는 또 다른 예시로 오토박싱(auto boxing)이 있다.

## Auto boxing 은 잘 확인하고 사용하자

> Auto Boxing 이란?
오토 박싱(Auto Boxing)은 자바에서 기본 자료형(primitive type)과 해당 기본 자료형을 래핑하는 객체 타입(wrapper type) 간의 자동 변환을 의미한다. 자바는 기본 자료형과 객체 타입을 서로 자동으로 변환하여 개발자가 코드를 더 편리하게 작성할 수 있도록 도와준다.
> 

> AutoBoxing 과 UnBoxing
> 
> 
> **오토 박싱(Auto Boxing)** : 기본 자료형을 해당 래퍼 클래스로 자동으로 변환하는 것.
> 
> **언박싱(Unboxing)** : 래퍼 클래스를 해당 기본 자료형으로 자동으로 변환하는 것.
> 

Auto Boxing 을 코드로 확인하면

```java
Integer a = 1;
int b = a + 2; // a를 int로 변환해준다.
```

위와 같다.

```java
private static long sum(){
    Long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
      sum += i;
    }
}
```

책에서는 위 코드를 예시로 들었는데, 정확한 답을 내기는 하지만 문자 하나 때문에 엄청나게 느려지니 이렇게 숨어있는 오토박싱을 조심하자고 한다.

위 코드는

```java
private static long sum(){
    long sum = 0L;
    for (long i = 0; i <= Integer.MAX_VALUE; i++) {
      sum += i;
    }
}
```

이렇게 리팩토링 할 수 있다.

이처럼 박싱된 기본 타입보다는 기본 타입을 사용하고, 의도치 않은 오토박싱이 숨어들지 않도록 조심해야한다.

## 주의할 점

객체 생성은 비싸니 피해라 라고 이해하면 안되고

생성 비용이 비싼 객체의 재사용을 고려해라! 라고 이해하자!