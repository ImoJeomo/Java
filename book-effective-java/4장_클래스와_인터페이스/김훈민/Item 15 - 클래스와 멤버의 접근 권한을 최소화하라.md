# Item 15 - 클래스와 멤버의 접근 권한을 최소화하라

## 잘 설계된 컴포넌트란?

- 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 잘 숨긴 컴포넌트
- 내부 구현을 완벽히 숨기고, 구현과 API를 깔끔하게 분리한 컴포넌트
- API를 통해서만 다른 컴포넌트와 소통
- 서로의 내부 동작 방식에는 개의치 않음

즉, 정보 은닉과 캡슐화가 잘되어있는 컴포넌트가 잘 설계된 컴포넌트이다!

## 정보 은닉의 장점?

- 시스템 개발 속도가 높다
    - 여러 컴포넌트를 병렬로 개발할 수 있기 때문
- 시스템 관리 비용이 낮다
    - 다른 컴포넌트로 교체하는 비용 낮음
    - 각 컴포넌트를 빠르게 파악 가능
        - 디버깅이 빠름
- 성능 최적화에 도움을 준다
    - 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화 할 수 있기 때문
- 소프트웨어 재사용성을 높임
    - 의존성 없이 독자적으로 동작할 수 있다면, 낯선 환경에서도 유용하게 쓰일 수 있기 때문
- 큰 시스템을 제작하는 난이도를 낮춰줌
    - 개별 컴포넌트의 동작을 검증할 수 있기 때문

## 정보 은닉을 잘하기 위해서 접근 제한자를 활용하자!

기본 원칙은 **모든 클래스와 멤버의 접근성을 가능한 한 좁히는 것**

### 톱 레벨 클래스, 인터페이스

톱 레벨이란 가장 바깥이라는 의미이다.

여기에 부여할 수 있는 접근 수준은 package-private와 public 이다.

1. pacakage-private
    1. 해당 패키지 안에서만 이용할 수 있음
    2. 패키지 외부에서 쓸 이유가 없을 때 사용
    3. 내부 구현이 되어 언제든 수정이 가능
    4. 클라이언트에 아무런 피해 없이 다음 릴리즈 version에서 수정, 교체, 제거가 가능
2. public
    1. 공개 API
    2. 하위 호환을 위해서 지속적인 관리 필요

public일 필요가 없는 클래스의 접근 수준을 package-private 톱 레벨 클래스로 좁히자

### 멤버 (필드, 메서드, 중첩 클래스, 중첩 인터페이스)

- 접근 수준의 종류
    - private : 해당 클래스에서만 접근 가능
    - package-private : 클래스와 같은 패키지에서 접근 가능
    - protected : 같은 패키지, 하위 클래스의 패키지에서 접근 가능
    - public : 모든 곳에서 접근 가능
- 클래스의 공개 API가 아닌 멤버들은 전부 **private**으로 만들자.
- 그리고 같은 패키지의 다른 클래스가 접근해야 하는 멤버가 있다면 package-private로 풀어주자
- private와 package-private 멤버는 해당 클래스의 구현에 해당하므로 공개 API에 영향을 주지 않는다.
    - 단 `Serializable` 을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수도 있다.

위 과정을 통해 멤버 접근성을 좁혀야하는데, 그것을 방해하는 제약이 있다.

“상위 클래스의 메서드를 재정의할 때는 접근 수준을 상위 클래스보다 좁게 설정할 수 있다” 라는 제약이 이 경우 문제가 된다.

그렇다고 이 제약이 잘못된 것은 아니고, 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 리스코프 치환 원칙을 지키기 위해서 필요하다.

## 주의점

### public 클래스의 인스턴스 필드는 되도록 public 이 아니어야 한다

- 필드가 가변객체를 참조하거나, final이 아닌 인스턴스 필드를 public으로 선언하면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. ⇒ 불변식을 보장할 수 없다
- 필드가 수정될 때 다른 작업을 할 수 없게 되므로 쓰레드에 안전하지 않다.

### 위에 대한 예외

- 해당 클래스가 표현하는 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 된다.
    - 관례상 이런 상수의 이름은 대문자 알파벳
    - 각 단어사이에 밑줄을 넣자
    - 반드시 기본 타입 값이나 불변 객체를 참조하자

### 길이가 0이 아닌 배열은 모두 변경 가능하다

- 클래스에서 public static final 배열 필드를 두거나, 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.
    - 클라이언트에서 그 배열의 내용을 수정할 수 있기 때문이다

```java
public static final Thing[] VALUES = {...};
```

### 위에 대한 해결 방법

1. 앞 코드의 public 배열을 private으로 만들고 public 불변 리스트를 추가한다

```java
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

1. 배열을 private으로 만들고 복사본을 반환하는 public 메서드를 추가하는 방법 (방어적 복사)

```java
public static final Thing[] VALUES = {...};
public static final Thing[] values(){
		return PRIVATE_VALUES.clone();
}
```

## JAVA 9 의 모듈 시스템

- 두가지 암묵적 접근 수준이 추가되었다
- 패키지 ⇒ 클래스들의 묶음
- 모듈 ⇒ 패키지들의 묶음
- 모듈은 자신이 속하는 패키지 중 공개(export)할 것들을 module-info.java에 선언할 수 있다.
    - protected, public 멤버라도 패키지를 공개하지 않았다면 모듈 외부에서는 접근 불가능
- 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서는 자유롭게 공유할 수 있음
- 예시로는 JDK가 있음
    - 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대로 접근할 수 없음.
- JDK 외에도 모듈 개념이 널리 받아들여질지 예측하기에는 이른 감이 있다.
    - 꼭 필요한 경우가 아니라면 당분간은 사용하지 않는 것이 좋을듯..?